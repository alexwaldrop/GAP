import logging

class NodeValidator(object):
    # Class for checking whether a node's requirements are met before runtime

    def __init__(self, pipeline_config, platform_config, input_data):
        self.pipeline_config = pipeline_config
        self.platform_config = platform_config
        self.input_data = input_data
        self.has_errors = False

    def report_error(self, msg):
        logging.error(msg)
        self.has_errors = True

    def validate_final_output(self, node):
        # Checks to determine whether the output files produced by a node
        # are consistent with output file types the user expects in the config

        # Get output types expected for node specified in config
        requested_output_types   = node.get_final_output_types()

        # Get actual output types generated by node
        actual_output_types = self.get_node_output_types(node)

        # Look for any discrepancies
        for output_type in requested_output_types:
            if output_type not in actual_output_types:
                # Report the error
                msg = "Module '%s' does not produce output files of type '%s'! Please correct 'final_output' section of %s in pipeline config!" \
                      % (node.module_name, output_type, node.tool_id)
                self.report_error(msg)

    def validate_node_resource_requirements(self, node):
        # Checks whether node resource requirments are satisfied by at least one available resource type

        # Get expected resources for a node
        expected_resource_types  = self.get_node_resource_types(node)

        # Get list of resources available to a node
        available_resources  = self.pipeline_config["paths"]

        # Initialize list of missing resources
        missing_resource_types = []
        for resource_type in expected_resource_types:
            # Count number of resources for each expected type
            count = self.count_resources_of_type(resource_type=resource_type,
                                                 resources = available_resources)
            if count == 0:
                # Case: Resource missing
                missing_resource_types.append(resource_type)

        # Report missing types
        if len(missing_resource_types) > 0:
            msg = "For the %s (%s), the following tools are required, but are not found in the config: %s "\
                  % (node.tool_id, node.module_name, " ".join(missing_resource_types))
            self.report_error(msg)

    def validate_node_resource_conflicts(self, node):
        # Checks whether node resource conflicts are resolved in the config
        # Get expected resources for a node
        expected_resource_types = self.get_node_resource_types(node)

        # Get list of resources available to a node
        available_resources = self.pipeline_config["paths"]

        # Initialize list of missing resources
        conflicting_resource_types = []
        for resource_type in expected_resource_types:
            # Count number of resources for each expected type
            count = self.count_resources_of_type(resource_type=resource_type,
                                                 resources=available_resources)
            if count > 1:
                # Case: Resource missing
                conflicting_resource_types.append(resource_type)

        # Check to determine whether the disambiguated

        # Report missing types
        if len(missing_resource_types) > 0:
            msg = "For the %s (%s), the following tools are required, but are not found in the config: %s " \
                  % (node.tool_id, node.module_name, " ".join(missing_resource_types))
            self.report_error(msg)

        # Get expected resources for a node
        expected_resource_types  = self.get_node_resource_types(node)

        # Get list of resources available to a node
        available_resources  = self.pipeline_config["paths"]

        # Initialize list of missing resources
        missing_resource_types = []
        for resource_type in expected_resource_types:
            # Count number of resources for each expected type
            count = self.count_resources_of_type(resource_type=resource_type,
                                                 resources = available_resources)
            if count == 0:
                # Case: Resource missing
                missing_resource_types.append(resource_type)

        # Report missing types
        if len(missing_resource_types) > 0:
            msg = "For the %s (%s), the following tools are required, but are not found in the config: %s "\
                  % (node.tool_id, node.module_name, " ".join(missing_resource_types))
            self.report_error(msg)

    def get_node_output_types(self, node):
        # Returns list of output file produced by a node
        output_types = list()
        if node.is_split_mode():
            output_types.extend(node.split_obj.get_output_types())
            output_types.extend(node.main_obj.get_output_types())
            output_types.extend(node.merge_obj.get_output_types())
        else:
            output_types.extend(node.main_obj.get_output_types())
        return output_types

    def get_node_resource_types(self, node):
        # Generating an aggregated not_found dictionary
        resource_types = list()

        # Generating the list of modules to check
        if node.is_split_mode:
            modules_to_check = [node.split_obj, node.main_obj, node.merge_obj]
        else:
            modules_to_check = [node.main_obj]

        # Obtiaining the list of requirements that are not met
        for module_obj in modules_to_check:
            resource_types.extend(module_obj.get_required_resource_types())
        return resource_types

    def count_resources_of_type(self, resource_type, resources):
        # Count the number of resource files in a set matching a given type
        count = 0
        for resource_name, resource in resources.iteritems():
            res_type = resource.get_file_type()
            if res_type == resource_type:
                count += 1
        return count


